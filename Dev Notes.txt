DEV NOTES

30.05.2017 - KICK OFF
- Template'ler çizildi
- Fikir ana taslak olarak belirlendi

MainScene
- Phone contacts'tan kişileri çekecek
- Bu kişileri isimlerine göre MainScene'de bulunan ListView'e atacak
- ListView'deki adapter custom 100
- Bu ListView'deki sıralama Social Points'e göre belirlenecek
- Social points yapılan aramalara göre bir puanlama sistemi
- Progress bar'ına benzer bir bar ile Social points görselleştirilecek
- ListView'deki bir item'e tıklandığında ilgili item için HistoryScene'e yönlendirilecek
- Social points'in azalmasına göre notification yapılacak
- Gerekli user-permission'lar alınacak
- SQLLite Kullanılması amaçlanıyor ve dolayısıyla Thread

HistoryScene
- Herbir kontak için özel bir HistoryScene olacak
- HistoryScene'de bu kişiye yapılan en son aramalar ve temaslar listenelecek
- Bir Floating Button ile bu kişiyi arama sağlanabilecek

ActionBar
- Settings kısmı eklenebilir

+ Diğer social network'ler ile güçlendirilebilir mi?
+ HistryScene'de arama seçeneğine basıldığında bu social network'lere bağlanma özelliği olabilir mi?

PersonData.class > Data Model

03.06.2017
- activity_main_layout oluşturuldu
- fragment_main_layout oluşturuldu
- PersonData Model oluşturuldu.
- main_fragment_layout'un ana LinearLayout'unun içine ListView widget eklenir ve ID'si @android:id/list yapılır.
- Liste boş olduğunda gösterilecek text için aynı ana LinearLayout'un içinde ListView'in altına TextView widget eklendi ve ID'si @android:empty yapıldı.
- MainFragment'ta onCreateView cycle yapıldı ve MainActivity'de belirtilem FrameLayout container üzerine inflate yapıldı.
- MainFragment on ActivityCreated cycle yapıldı. ArrayAdapter burda initiate yapıldı ve setListAdapter ile view ve model arasında bağlantı kuruldu.

04.06.2017
- Custom Adapter için kullanılacak olan row layout hazırlandı. bir ImageView ve 3 TextView konuldu.
-CustomAdapter'in her row'u için özel row layout hazırlandı. Bu row layout'ta 3 TextView birbirinden çok ayrı görünüyor ama ListView'e eklendiğinde aradaki bu mesafeler daralıyor.
-PersonData class'ı için Singleton yapıldı. ArrayList<PersonData> olarak member field yapıldı. Getters & Setters'lar koyuldu.
-Singleton'ı PersonDataSingleton.getInstance().getPersonDataList() kodunu assign yaparak kullanabilirsin. Singleton .add() ile dummy kod test edildi çalışıyor.
-CustomAdapter hazırlandı. CustomAdapter içinde Singleton'ın içindeki PersonDataList kullanıldı. TextView ve Resimler'e View-Model bağlantısı yapıldı. getItem(position) methodu kulanıldı. 
-CustomAdapter'da setText() methodunu int verilerine kullandığında RunTime error veriyor. Bu nedenle int verileri String.valueOf() methodu ile String'e dönüştürmen gerekli.
-MainFragmnt'ta onActivityCreated cycle'da CustomAdapter oluşturuldu ve setListAdapter() methodu ile model-View bağlandı.
-Farklı resimler ile test edildi. Adapter model ile view arasındaki bağlantıyı sağlıyor.

10.06.2017
-PersonData'ya mSocialPoint field'i ekledim. Ve Custom Adapter ile MainFragment'ta ilgili düzeltmeleri yaptım. HistoryId'nin yerine SocialPoint gözükecek UI'de. Bluestacks'te test ettim çalışıyor.
-SocialPoint için CustomAdapter'da TextView yerine SeekBar eklendi. Seekbar.setClickable(false), SeekBar.setFocusable(false) ve seekBar.setEnabled(false) yapıldı. Bu sayede SeekBar'a herhangi bir şekilde dokuunamıyorsun. Tüm bunları setProgress() methodundan sonra yazdık. Önce sonra bir etkisi olur mu? Denenebilir.
-SeekBar.setProgress() methoduna parameter olarak SocialPoint eklendiğinde SeekBAr int olarak bu SocialPoint'i alıyor.
-seekBar.setTHumb(null) yapılarak bar üzerindeki gösterge kaldırıldı.
-AndroidMAnifest'te <application> hemen üstüne <uses-permission> ile phone contact için READ permission istedim.
-CustomAdapter'da TextView ile aldığımız Name ve Phoen neumber için TExtView yerine Phone Detaiks database'indeki isim ve telefon numaralarını çekeceğiz. Bu nedenle cursor kullanıyoruz. getContentResolver() methodunu kullanabilmek için content'i tanıtmak gerekiyor bu nedenle bu meythodu getContent.getContentResolver() şeklinde kullanıyoruz.
-projection isimli bir Array oluşturarak çekmek istediğimiz bilgileri bu array'e yazıyoruz. Sonra Cursor class oluşturarak bu bilgileri projection'ı burada kullanarak query ediyoruz. Cursor'ın içinde getColumnIndex ve getString methodları ile bu bilgileri String'e dönüştürüp kullanabiliyoruz.
-Telefon numarası ContactsContract.CommonDataKinds.Phone.NUMBER, Kontak ismi ise ContactsContract.Contacts.DISPLAY_NAME ile isteniyor. Aradaki farka dikkat et.
-Kontaklara ulaşmak için permission'ı runtime'da istemek zorundayım aksi takdirde telefon izin vermiyor. Runtime error veriyor.
-Önemli kısayollar: alt+enter, crtl+space, Ctrl+Alt+O

11.06.2017
-Telefon'un Contact details'ına girmek istediğimiz için API 23'ten büyük olan cihazlar için manifest'in yanında Runtime permission request gerekiyor. API 23'ten düşük olanlarda ise manifestte request yapmak yeterli. Bu cihazlarda siyah veya beyaz: Ya yükler herşeye ok verir ya da yüklemez zaten app çalışmaz.
-Runtime Permission için Support library kullanımı tavsiye ediliyor ama ben library kullanmadım.
-İlk önce OnCreate'te cihazın API'sıne göre bir if condition yazıyoruz. API'sı 23'ten büyük olanların permission'ını kontrole diyoruz. Burada kullandığımız checkSelfPermission() methodu sadece API 23 ve üzeri cihazlarda kullanılabiliyor. READ_CONTACTS için izin sordum. İzi yoksa requestPermission() methodu ile izin talep ediyorsun. Burada rastgele bir static final constant ID numarası vermen gerekiyor.
-İzin istedikten sonra kullanıcıya bir dialog box ile allow veya deny seçeneği sunuluyor. Kullanıcıın verdiği bu cevabı onCReate cycle'ın dışında onRequestPermissionsResult cycle'ı Override ederek öğrenebiliyoruz. Ama bu Cycle'ın onCreate'in dışında olduğu için kullanıcı Allow demişse burada bir method çalıştırmak (örneğin fragment transaction) onCreate'e etki etmeyeceği için sadece bir kere çalışır, uygulamayı birkez ada başlattığımızda onCreate cycle'da birşey olmadığı için bu method bir daha çalışmaz Yani onRequestPermissionsResult kullanıcı ALLOW yanıtını vermişse birkez çalılıyor ve bunu hafıza kaydediyor. Kullanıcı DENY yanıtını verdiyse her uygulamayı çalıştırdığında bu soru soruluyor, ta ki Kullanıcı "never ask again" diyene kadar. 
- Bu nedenle fragment'ın her açıldığında çallışması için ben aşağıdaki yöntemi kullandım:
1- if API > 23 ise
     if checkSelfPermission()
       izin varsa: fragment transaction
     else
       izin yoksa permissionRequest()

2- if API < 23
     direk fragment transaction

3- if onRequestPermissionsResult
     Kullanıcı ALLOw dediyse: fragment transaction
    else
      Kullanıcı DENY dediyse: Uyarı yazısı veya başka bir fragment

- Dikkat edilmesi gereken bir nokta, onRequestPermissionsResult() cycle'da onCreate() cycle'da olduğu gibi savedInstanceState olmadığı için fragment Transaction sırasında ==null kullanamıyorsun. OnCreate() cycle'daki Bundle'ı variable kullanarak buraya taşındı. (Bundle savedInstanceStateTwin = savedInstanceState gibi) 

18.06.2017
- CustommAdapter1 class'ın da ArrayAdapter extendss edilmmiş. Ancak sen Phone Contacts'ları çekebilmek için Cursor kullanıyorsun. Bu nedenle Cursor Adapter'ı inşa etmelisin.
- Database'den SQLLite'tan veri alınıyorsa bu Cursor oluyor ve bu durumda mutlaka CursorAdapter kullanılması lazım. Zaten Phone COntacts verileri de Android'in kendi Database'inden çekiliyor.
- CursorAdapter hazırlandı. CursorAdapter newView ve bindView method'ları Override yapıldı. ContactsContract Cursor'u için projection ve getContentResolver() methodları CustomAdapter'ın içinde değil, MainFragment'ın içinde kullanıldı. CustomAdapter'ın içinde BindView method'unda getColumnIndex method'ları ile contactName ve contactNumber custom layout'taki ilgili wigdet'lar ile bağlandı.
- CursorAdapter: Adapter that exposes data from a Cursor to a ListView widget.
- The Cursor must include a column named "_id" or this class will not work. Therefore, you must add _id to the projection so that the resulting cursor will have that column. Bu nedenle MainFragment'ta Cursor'un projection Array'ınde ilk item olark BaseColumns._ID
- Recommended constructor: CursorAdapter(Context context, Cursor c, int flags). MainFragment'ta CursorAdapter'ın bu consturtcor'ına call yapıldı. Bu contsructor CustomCursorAdapter1 class'ında tanımlanmıştı.
- Cursor'ın Phone Contact Database'inden query'sini CustomCursorAdapter'dan alıp, MainFragment'e ekliyoruz. Llistview ile cursor'un birleştirmesini MainFragment'ta yapıyoruz.
- You should also call cursor.close() everytime you are done with your cursor. close() methodunu önce CursorAdapter'da denedim olmadı. Sonra MainFragment'ta denedim yine olmadı. İkisinde de Cursor kapandıktan sonra Cursor'a ulaşmaya çalışıyorsun şeklinde bir hata mesajı geldi. close() methodunu tamamiyle kaldırınca Cursoradapter database'den bilgileri alıp View'lere aktardı. Ancak bizim mutlaka Cursor.close() yapmamız gerekiyor. Bunu nerde Cursor.close() yapacağımızı bul.
- Cursor.moveToFirst(); şeklinde hiç method kullanılmadı. ANcak birçok örnekte mevcut. Bu ne işe yarar?
- Adroid Studio emulator'de test edildiğinde normal sayıda Phone Contact listeye geliyor ama API düşük olan BlueStack'te test edildğinde aynı PhoneContact'tan iki tane listeye geliyor. Nedeni nedir? Sorun nasıl çözülür?

24.06.2017
- Geçen hafta Phone Contacts'ı telefonun database'inden Cursor olarak çektiğimiz için listview'de bunları gösterirken de CursorAdapter kullanmam gerektiğini yazmıştım. Ama şimdi bunun yanlış olduğunu düşünüyorum. Database'den cursor olarak çekeceğiz. Ama sonra bu cursor'daki bilgileri String'e çevirip Array Adapter içinde kullanmayı deneyeceğiz.
- Arrayadapter'ı eskisi gibi kurduk. Eski CUstomAdapter class'ı kullandık. Burdaki tüm Cursor'ları sildik. Tüm cursor'ları MainFragment'ta kullandık. Main Fragment'ta bir while methodu ile Cursor'ları içindeki DISPLAY_NAME ile PHONE_NUMBER'ı contactName ve contactNumber değişkenlerine aktardık. while(mCursor.moveToNext() kullandık. Bu değişkenleri Singleton içindeki PersonData ArrayList'in içine dummy kod ile birlikte yerleştirdik. Çalıştı.
- PersonData içindeki PhoneNumber'ın Type'ını int'ten Strng'e çevirdik. Çünkü Cursor String olarak çekiyor ve PersonData Constructor'ı kullnırken sorun oluyordu.
-Cursor query'de ID'ye ek olarak LOOKUP_KEY'i de ekledik. Belirli bir contact'ı bulabilmek iiçin bu ikisini kullanacağız. Çünkü Contact'lar yenilenirse,  update yapılırsa ID ve LOOKUP_KEY değişiiyor. Test ettim LOOKUP_KEY'ins on 2-3 rakamı değişti. Bu nedenle bir cotact bluunurken LOOKUP_KEY'in kullanıp URİ üzerinden gidilmeli yazıyor.

02.07.2017
- SQLite Database kuruldu. Yani bir class oluşturularak buraya SQLite database için gerekli callback method'lar yazıldı. 3 colum oluşturuldu - lookup, social points, history id. Daha sonra MainFragment sayfasında bu database initiate yapıldı ve bu Database'in lookup colunmuna CONTACTS'tan alınan lookup key yerleştirildi. 
- YAPILACAKLAR: 1) Main Fragment'taki singleton içindei listeye new ile PersonData oluşturulurken while methodu içinde ikinci bir while methodu kullanılarak ikinci Database'in içindeki social point ve history id fetch yapışabilir mi? Burada iki Database arasındaki ortak nokta Lookup ket olduu için bu lookup key üzerinden nasıl bu iki database birleştrilebilir? 2)CONTACTS'tan alınan lookup Key STring'ine match olan column bulunacaj bu bu columndaki social point ve history Id'ye ulaşılacak.
-MainFragment'ta onDestroy methodunda db.close() ile database'i leak yapmaması için kapatıyoruz.
!!!ÖNEMLİ NOT!!!: SQLLiteDataBaseHelper onject'ini onCreate methodunun içinde declare yaptığım için onCreate'in dışında yani onDestory'da bu object'i tanımıyordu. Yani bütün declaration'ları onCreate'in hemen üstünde yan global scope'ta yap!!!!

04.07.2017
- bir ara android studio'da emulator kullanarak test etme mekanizması çalışmıyordu. LogCat'te Messages bölümünde Error:Execution failed for task ':app:buildInfoDebugLoader' hatası veriyor ve uygulama açılmıyor veya uygulamayı sildiğimde yeniden yüklemiyordu. BUILD > CLEAN Project yapıp sonra BUILD > Rebuild Project yapınca sorun düzeldi.
-SQLLite'te query() methodundaki parametreler aslında SELECT Columns FROM TABLE WHERE columns ... 'un virgüllerle ayrılmış hali. Boş bırakmak için null yazıyorsun.

08.07.2017
-cursor.movefirst kullanılarak Cursor içindeki ilk recorda erişilebilir.
-sqllite database test edidi çalışıyor
-Nexus5'te Index -1 size 0 hatası aldık. Çünkü hiç kontak olmadığı için database de hiç kontak look up key yoktu.
-Uygulamalrın içindeki dosyaları görebilmek için Tools > Android > Android DEvice Monitor ADM kullanmak gerekli. Ancak API 24 ve üzerinde çalışmıyor. Bu nedenle API 23 olan bir cihaz kullanıldı. Önce cihazda ilgili uygulamayı yükle. ADM yi çalıştır sonra uygulamayı tekrar çalıştır. ADM nin içinde File Explorer'dan data > data > uygulama nı bularak içindeki dosyalara ulaşabilirsin.
-ADM çalıştrılmadan önce Tools'tan Enable ADB Integration check yapıldı.
-File Explorer içinden text veya database dosyalarını bulup Pull File from Device düğmesi ile masa üstüne kaydedebilirsin. Push File ile cihaza dosya kaydedebilirsin.
-Database dosyalarını açabilmek içiin third party program indirmek gerekli. Vey github internet sitesindeki bir sayfadan kontrol edilebiliyor. (http://inloop.github.io/sqlite-viewer/)
- Database konrol edildi. Yazılan kod ile Contacts database'inden Look-up Key String olarak alınıp SOcialbars database'indeki Look_up sütununa String olarak atılıyor.
-ADM'ün çalışması için Android Studio'yu yönetici olarak başlat

09.07.2017
-Datasabe'de query methodunda slection parametresinde sonunda mutlaka +"=?" kullanman gerekiyor. Çünkü bu işaret kaç tane arguement'a ihtiyacın olduğunu belirtiyor. Bir sonraki selectionArgs Array'inde bu işaret replace ediliyor gibi düşünebilirsin. Yoksa java.lang.IllegalArgumentException: hata mesajı alıyorsun
-Sqllite database'de values'e social points ve history_id random verileri de eklendi ve databae'e insert yapıldı.
- Database query methodunda .... Look_up key'ine sahip Social_points sütunundaki veriler fetch yapıldı. TEst başarılı oldu.
- Uygulama her başlatıldığında socialbars database'indeki tabloya aynı veriler tekrar tekrar giriliyor. Tekrarı önlemek için bir şey yapmak lazım.
- ÖNERİ: Bir düğme eklenip, bu düğmeye basıldığında .... LOOK_UP key'e sahip social points +20 adtsın dene. Yapılabiyor mu? Bunu Phone call'a bağlayacağız. Ayrıca tüm bu database write/read olayını diğer Contact database'indeki while içinde yapabiliyor muyuz? Yapabiliyorsak belki bunu ayrı bir method olaak yapıpı sonra sadece bu methodu while içinde burda call yapabiliriz.

29.07.2017
-bir kişinin lookup key'den social points arttırılabilir mi? bu denendi. testString int yapıldı. CUrsor'dan getString methodu yerine getInt() methodu kullanıldı. 20 ilave edilerek farklı bir COntenValues kullanılarak database table'a eklendi. Öellikle .... Lookup Key'in satırına eklenebilmesi için update() methodu kullanıldı. var olan belirli bir record'u güncellemek istiyorsan update() kullan. Çünkü Burada bir where clause mevcut. Bu where clause2una hangi lookup key'in bulundupu satırın güncellenmesi isteniyorsa o yazılıyor. Bu şekilde tabloda o satır update oluyor. Hangi ContentValues eklendiyse sadece o sütün update oluyor. Diğerleri aynı kalıyor.
-Update() mehodunu kullanırken selection alanında column name'in sonuna +"= ?" koymak gerekiyor. Yoksa java.lang.IllegalArgumentException: Too many bind arguments.  2 arguments were provided but the statement needs 1 arguments hatası veriyor. 
-insert yerine replace() methodunu kullan. Çünkü bu method eger record varsa onu güncelliyor yeni oluşturöuyor. Eğer record yoksa onu oluturuyor. BEst of both worlds. Insert sadece yeni satır ekliyor.
-aynı değer varsa ilave database'e ekleme yapılmasın. Bu sayede zaten otomatik bağlantı kurulmuş olacak loookup key'ler üzerinden?
- PRoblem: Social poimts arttırma süreci sadece bir sonraki record'a etki yapıyor. Yani 90 - 90 - 90 - 70 diye gidiyor. Baştaki 110 olmuyor yani. Burda ayrıca replace() methodu da düşündüğümüz gibi çalışmadı. Yani hr seferinde yeni bir kayıt ekleniyor.

30.07.2017
-Spcial points icrease sorunu çözüldü. Yöntem olarak: 1. list içeren mainfragment layout'un en altına bir layout ve icine bir dugme eklendi. 2.Fragment'a View.OnClickListener interface implent edildi. OnCreateView içinde bu düğme initiliaze yapıldı ve .setOnclicklistener(this) methodu ile listener eklendi. OnCreateView'ın dışına tamamen ayrı olarak public void onClick(View view) methodu override yapıldı. Bu methoda button id'sini tanıyacak şekilde swithc-case yapıldı. Bu onClick methodu içine daha önce oCreate cycle'da bulunan sqlDbRead, sqlWrite, projectionTest, cursorTest bu method'un içine alındı. Daha sonra method'a bir while eklendi. Bu  while'a Social Points increase için ilgili statement ve method'lar yazıldı. While bittikten sonra da sqlRead ve sqlWrite close ile kapatıldı. Yöntem test edildi. Her düğmeye basıldığında artış Toast mesajında görünüyor. Ayrı bir methoda yüklenebilir. Facade design pattern.
- Bu yöntemde kulanılan cursor ve sqlRead gibi objeler için if clause ile varsa yeniden oluşturma gibi bir çalışma yapılması gerekir mi? Örnek:if(cursor != null && !cursor.isClosed()){ cursor.close(); }  

06.08.2017
-bir uygulama ilk yüklenirken database oluşturuyor. Sonra bu database class'ında değişiklik yapsan kaydetsen ve o uygulamayı silmeden update etsen bile o değişiklik database'e etki etmiyor, çünkü onCreate methodu yalnızca Database mevcut değilse oluşturmak için bir kez call yapılıyor. Değişiklik olabilmesi için database'in upgrade methodunda bu değişikliği yapman ve bu update methodundaki Schema versiyonlarını eski ile yenisine bağlaman gerikiyor. Biraz komplike bir olau. Ancakuygulamayı silip tekrar yüklersen database'de silineceği için tekrar yüklediğinde Database'in onCreate() methoduu call yapacağından istediğin değişikliğe ulaşmış olursun.
- Button düğmesine her tıklandığında testString artıyor ve bu database'e kayıt ediliyor. Ancak Uygulama her sonlandırılııp tekrar başlatıldığında aynı kkayıtın tekrar oluşturuldupunu ve database'de sürekli yenilendiğini farkettim. Biraz araştırınca bu sorunun sqllite'ta kullanılan replace() methodu çalışması için bir primary key sütununa ihtiyaç duymasından kaynaklandığı yazıyor. To be able to use the replace() method, you need a UNIQUE or PRIMARY KEY constraint on the table. DatabaseHelper class'ı içindeki onCreate() methodunda sqLiteDatabase.execSQL() methodu içindeki "column_lookup TEXT" ifadesi, "column_lookup TEXT PRIMARY KEY" olarak yenilendi. Bu sayede uygulama kapatılıp açılsa bile kayıtlar yenilenmiyor. Aynı kayıttan sadece bir tane oluşturuluyor. Ancak bu esnada farklı bir soru tespit ettim. Button'a basılınca testString'i değiştiren bu fonksiyon yalnıca database'de aynı veriden 2 tane veya daha fazla çalışıyor. Yani aynı veridenn bir tane varsa testString ne bu kayıtın socialpoint'ini değiştiriyor ne de tstString Toast'u çıkıyor Aynı veriden 2 tane varsa bir testString Toast'u çıkıyor ve kayıtları hepsi değişiyor. Aynı veriden 3 tane varsa 2 testString Toast'u çıkıyor ve kayıtların hepsi değişiyor gibi. Bu soruun nedeni nedir? Bunu çözersen aynı kayıtlar eklenmeden bu kayıtlar içindeki social points'i manipule etme özelliğini elde edeceksin. Ki bundan sonra bu button arayüzünü silip bunu telefon etme arayüzü olarak değiştirebilirsen uygulamanın asıl amacına ulaşmış olacaksın. SORUNUN ÇÖZÜMÜNÜ BULDUM: Mal gibi Cursor iteration'ından önce cursor'ı moveToFirst() methodu ile ilk sıradaki kayıta atıyormuşum. Halbuki Cursor -1. sıradan başlıyor ve direk .next() methodunu uyguladığı için bir soraki kayıta geçiyor. Yani ben moveToFirst() methodunu kullanınca direk 0. kayıttan başlıyor ve next() methodhu ile bir sonraki kayıta geçiyor.  Eğer zaten sadece bir kayıt varsa o kayıtı atlayıp Cursor sonuna geçiyor yani boşluğa. moveToFirst() methodunu sildim. Bu sayede hem sadece bir kayıt oluşuyor hem de bu kayıtın verileri manipule edilip testString ile Toast'a yansıyor. İsediğini elde etmiş oldun. moveToFirst() methodu ise bir Cursor'ın içinin dolu olup olmadığını kontrol etmek için kullanılıyor Cursor'u başa sarmak için değil yani. Cursor zaten -1. pozisyondan yani en başın bir öncesinden başlayıp next() ile iterattion yapıyor.

12.08.2017
-Eskiden sadece Lookup_Key üzerinden gidip contact'ları belirliyorduk. Ancak yeni düzenleme ile Lookup_key ve Lookup_ID kullanılıp Lookup_Uri yapıldı. Code'da lookup_key yazan her yer lookup_Uri ile değiştirildi. TEst edildi. Hem own database hem de Toast ile istenilen elde edildi.

Yapılcaklar:
-Runtime permission'a READ_CALL_LOG ekle,
-Aşağıdaki kodu onClick methodu içinde ilk while'dan sonra ikinci while açarak yaz. Toast ile test et. İstenilen veriler alınabiliyor mu diye. Tabi eulatorden contactları ara önce!!!
-Son olarak for (int : i) tarzı veya bir while loop ile (veya içiçe 2 tane) call log içindeki aranan veya arayan duration'ı 1'in üzerindeki contactları lookup uri ile own database içindeki social points ile etkinleştir. 
	1-calllog database'inie cursor ile giriş yap. 
	2-Database'in içinde en son record'un Epcohtime'ını bir varible 	ile persistence kayde. Uygulama her açıldığında bu date'ten 	sonraki recordları alsın. (Başka bir önerin var mı?)
	3-Cursor içindeki record'ları LOOK_UP KEY'e göre belirleyip, 	DURATION'I 1'den büyük olan her arama için +20 SOcial points own 	Database'e yazılsın (Farklı duration'lar içi farklı social point?)


//ONCLCIK IÇINE CODE***
Cursor CallLogCursor = context.getContentResolver().query(CallLog.Calls.CONTENT_URI, null, CallLog.Calls.CACHED_LOOKUP_URI + "=?" , whereValues, null);

while (CallLogCursor.moveToNext()) {  

int number = cursor.getColumnIndex(CallLog.Calls.NUMBER);
int date = cursor.getColumnIndex(CallLog.Calls.DATE);
int duration = cursor.getColumnIndex(CallLog.Calls.DURATION);


}

cursor.close();   

13.08.2017
-String içinde birden fazla permission yazıldı. Tabi manifest'e de ilgili permission'lar için tek tek user:permission girişi yapıldı. Daha sonra bir API23 condition'ı içinde checkPermission() methodu kullanıldı onCreate içinde. Bu boolean methodu'nun true/false oluşuna göre fragment'ı başlatıyoruz. Ya da hata mesajı veriyoruz. CheckPermissions methodu içinde for loop ile herbir permisson için iziin alınıp alınmadığı gözden geçiriliyor ve bu sonuçlar bir ArrayList aktaralıp, Arraylist'in boş olup/olmadığı kontrol edilip ona göre requestPermission methodu call ediliyor. Single runtime permission için kullandığımız koda göre requestPermissonForResult methodunda bir değişiklik yapılmadı. Ancak ayrı olan checkSelfPermission methodları silinip custom checkPermission() methodu çine aldı. TEst edildi. Runtime permission çalışıyor.
-Fragment'ta Click methodu içinde CallLog.Calls'un database'inden cursor ile bilgiler alındı. Ve Toast mesajı ile bu bilgilere ulaşıldığı test edildi. Frgment içindeki CallLog declaration da runtime permission error'u altı kırmızı çizili olarak ifade ediliyor. Ancak zaten Activity'de runtime permission aldındığı için bu eltı kırmızı çizgili hatayı görmezden gelebikirsin. Çünkü Uygulama run denildiğinde çalışıyor.

19.06.2017
- CallLogs.Calls database itertion while loop'u Own Database Cursor while loop'u içine aldık. Projection'ları silerek tüm sütunların cursor'a alınmasını sağladık. Test edildiğinde her bir cursor için herbir CalLog.calls cursor'ının eşleştirilebildiği anlaşıldı. Burada CallLog.Calls while loop'undan hemen önce CallLogCursor.moveToPosition(-1); ifadesi eklenerek her iteration öncesi Cursor'un başa sarılması sağlandı.

20.08.2017
- Ancak CACHED_LOOKUO_URI'nın API 21 istemesi ve birebr eşleşme olmaması sebebiyle Telefon numarası üzerinden eşleştirmeye karar verdim. Burda da telefon numaralarının Contacts database'de parantezli iken
CallLogs.Call database'de parantezsiz olması sebebiyle replaceAll("\\D+", ""); RegEx ifadesini kullanmayı deneyeceğim. Bu ifade digi olmayan diğer tüm ifadeleri siliyor. İlk parameter RegEx ikinci parameter bu regex yerine geçecek String' ifdae ediyor. \D ifadesi a non-digit, \d ifadesi a digit demek. İşe yaradı. Calllog Database'deki arama verileri Own Database'deki RegEx ile düzeltilmiş Phone Number ile eşleştirilip, eşleşme olan numaraların sahiplerine social points ekleme yapılacak. 
- if condition kullanılarak CallLog.Calls Database'deki number String own Database'deki Number String'e equals() methodu ile eşit mi değil mi? Eşitse Social Points'i arttır dendi. Test edildi. İşe yarıyor. Uygulanan Toast method'ları da işlemin asıl yürüdüğü ile ilgili önemli bir gösterge sağlıyor. Equals() method'un dan önce iki String'in eşit olup/olmadığını "==" ile anlamaya çalışmıştım. (Tam bir saçmalık) NOT: use == for primitive data types only, use equals() method for objects and strings. 	
In Java two strings (and in general, two objects) must be compared using equals(), not ==. The == operator tests for identity (meaning: testing if two objects are exactly the same in memory), whereas the method equals() tests two objects for equality (meaning: testing if two objects have the same value), no matter if they're two different objects. Almost always you're interested in equality, not in identity.
- sqlLite update() methodu'unu CallLog.Calls database while'ını içinde if(num1.equals(num2) condition'ı içine aldım. Update() methodunun WHERE clause'unu (yani hangi record'a işlem yapacağı ile ilgili selection kısmını) testContactsNumer String'ine eşit olacak şekilde new String[] oluşturarak yaptım. Böylece eğer iki numara eşit ise own Database'de o numaranın sahip olduğo Social points artıyor ve update methodu ile database'e işleniyor.
- Calllog'a son erişim durumunda lastTime değişkeninin Date milisaniye olarak kaydedilip her query'de bu milisaniyeden sonraki verilerin query edilmesi isteniyordu. Dummy bir lastTime oluşturduk. bu kodu onClick methodu'unun dışına koyduk kş her onClick event'ta lastTime kendini tekrr eski değerine atamasın diye. CallLogCalls query'de WHERE Clause'un yazıldığı Selection parametresine CallLogs.Call.DATE ifadesini koyup yanına büyüktür "> ?" ifadesi yazıldı. Burada ilginç olan nokta bir sonraki parametrede burada ? koyulan kısma ne gelecek ise onu yazıyoruz. Biz bir sayı (long) ifadesi kullanacağız ancak bu parametre sadece String kabul ediyoruz. Ama bir önemi yok çünkü oraya bir String içinde sayı koyduğunda bunu sayı olarak okuyor kendi içinde. Yani String lastDate = 213123 yazıp bunu new String[] {lastDate} olarak ifade ettiğinde büyüktür/küçüktür karşılaştırmasını yapacaktır. OnClick method'unda en sonda break'ten önce LastDate CurrentTimeinMillis'e assign yapıldı. Bu sayede CallLog içinde sadece en gncel aramaların verilerinin alınması sağlandı. Bu şekilde test edilidğinde istenildiği gibi dummy milisTime'dan sonraki aramalar için socialpoints yükseldi. Sonra LastDate kendini CurrentMillis ile update edince düğmeye basıldığında başka arama olmadığı için socialpointsler yüksek kaldı. Tekrar bir arama yapıldığında ve düğmeye basıldığında siste bu aramayı göördü ve socialpoints'i yüksellti ve lastDate kendini tekrar update ettiği içn bir daha düğmeye basıldığında başka arama bulunamadı. Hatta dummy kod'dan sonra 3 arama yapıldıya aynı numaraya sistem social poimts'i x3 arttırıyor. Yani herşey istenildiği gibi.

Kısa özet:
1- contact database'den query edilip cursor ile contact ilgileri alınıyor
2- Bu contact bilgileri own database'e aktarılıyor replace/update ile
3- Ayrıca personDataList singleton'ına eklenip Listview'de çıkıyor her contact
4- Own datbase'den query edilip cursor ile veriler çekiliyor. Dummy social points eklenip write yapılıp kaydedeiliyor.
5- Calllog Database'den query edilip veriler çekiliyor
6- Calllog Database'deki arama verileri Own Database'deki lookup Uri ile eşleştirilip social points ekleme yapılacak. (Cached Lookup Uri? Phone number?)
7- Own databae yeni socialpoints değerleri ile write yapılıp kaydedilecek.
8- Calllog'a son erişim durumunda lastTime Date milisaniye olarak kaydedilip her query'de bu milisaniyeden sonraki veriler query edilecek

Yapılacak: *OnClick method'da çalışan sistemi düğmeyi sil ve Fragment'ın her açıldığında onStart cycle içine bu işlemleri method olarak ekle. *LastDate'i sharedpreference'a persistemace olacak şekilde ayarla (veya başka bir persistance sistemi ile). *query() methodularında sadece gerekli colum'lar çekilecek şekilde projection'ları güncelle. *Socialpoints'ler arttığında spinner'ların değerleri otomatik update olacak şekilde gerekli düzeltmeleri yap.

10.09.2017
- SharedPreference persistance yöntemi ile LastDate sharedpreference'a persistemace olacak şekilde ayarlandı. Önce SharedPreference class call yapıldı Context.MPDE_PRIVATE ile. Bu sayede başka uygulamalrın bizim sharedPreference'a müdahala etmesi engellendi. Sonra getString methodu ile "CallLogLastDate" key'i mevcutsa burdan value'sunun alınması, mevcut değil ise default değer olarak dummy "1503253053446" değerinin alınıp lastDate variable'ına assign yapılması sağlandı. En altta ise onclick methodu içinde lastDate güncellenmesi için bu sefer SharedPerefernce.Editor hazırlandı ve putString() method'u ile "CllLogLastDate" key'i içine lastDate variable'ının değerinin value olarak atanmasoı sağlandı. Daha sonra apply.() method'u ile SharedPreference persist olması sağlandı. Bu sayede  uygulama ilk açıldığında dummy value alınıyor ancak sonraki her açılışta SharedPreference içine kaydedilmiş olan CallLogLastDate değeri kullanılıyor. Test edildi. Çalışıyor. Önemli nokta: İlk önce SharedPrefernce class'ı onCreate dışında initailize ve declaration yapıldı. Ancak böyle olunca nullpointer hatası alındı. Çünkü getActivity method'unun Activity'yi görebilmesi için bu declration'ın onCreate cycle içinde yapılması gerekiyor. Bu declaration oncreate cyle içine alındı ve çalıştı. ancak böyle yapınca bu sefer de onClick method'u içinde tekrardan SharedPreference class'ın declaration yapılması gerekti.
- Socialpoints'ler arttığında spinner'ların değerleri otomatik update olacak şekilde gerekli düzeltmeleri yapılması ve Button özelliğinin onStart'a bağlanması (Daha doğrusu onCreate'e bağlanması) sağlandı. İzlenen yol şu oldu: İlk önce onClick methodu'unda yer alan iki nested while loop onCreate method'unda en üste taşındı. Daha sonra PhoneContacts database'inden cursor çekilen while loop'un içine if condition ile SharedPreference kullanılarak uygulamanın ilk edfa açılıp açılmadığı kontrol edildi. if(sharedPref.getBoolean("isFirstTime", true)) ifadesi ile isFirstTime key'i yoksa zaten default olarak true olacak yani uygulama ilk kez başlatılıyor demek olacak ve bu kod bloğu dummy 50 points olarak PersonDataList'e ekleme yapacaktır. ama daha sonra aşağıda "isFirstTime" key'inin değeri false a çevrildi. Bu sayede uygulama tekrar başladığında else bölümündeki kod call yapılıyor. İşte bu else bölümüne ikinci bir while loop eklendi. Bu while loop'da telefon numaraları aynı ise personDataList'e kayıt eklenmesi şeklinde kod dizayn edildi. Bu while loop'ta daha önce yapıldığı gibi cursorTest.moveToPosition(-1); ile cursor başa sarıldı. bunun sebebi üst kısımda bu cursor kullanıldığından sonda kalmıştı pointer. Bu nedenle başa sarılması gerekmek her kullanım öncesinde. Uygulama test edildi ve çalıştığı gözlendi. onCreate()'te ilk iki nested while loop bir if condition'ı içine alınabilir. bu sayede CallLog Cursor'u boş ise hiç bu while loop'ları çalıştırmaya gerek kalmaz.  f else kodundaki mantık şu: eğer ilk kez açılıyorsa own Database'e dummy kod write yapılıp personData intiate yapılıyor. Else kodunda ise own Database'den veriler çeklilip bu veriler kullanılarak PersonData object leri call yapılıtor.  TODO: Add if (CallLogCuror is empty) {skip these loops}!! PersonDataList'in sinfgleton ama hiçbir persistance özelliği yok. Biz ona ne add dersek o onu ekliyor her uygulama açılıp kapandığında. Yani tüm persistance own Database üzerinden yürüyor. ayrıca spinner'ın değeri uygulama tekrar açıldığında bir önceki değeri gösteriyor. Bunun nedenin ArrayAdapter'ın notify yapılmaması olduğuu düşünüyorum. TODO: ArrayAdaper notifylist()?? I  Ayrıca TODO: query() methodularında sadece gerekli colum'lar çekilecek şekilde projection'ları güncelle.

16.09.2017
-Geçtiğimiz hafta yapılan değişikliklere istinaden uygulama ilk başladığında 2 ayrı netsed while loop ile database'lerden verilerin alınarak gerekli işlemlerin yapılması sağlanmıştı. Ancak bu işlemler oCreate cycle içinde olduğundan sadece uygulama başladığında çalışıyor. Uygulamanın backstack'e yollanamsı ile oluşan onStop, onStart life cycle'larında hiç bir işlem olmuyordu. Ancak bu işlemlerin mutlaka onCreaate method'ta da olması gerekiyor. Çünkü OnActivityCreated'da adapeter'ı kuruyoruz. Bu ife cycle onStart life cycle'dan önce geliyor. Eğer biz bu işlemleri onStart'a taşırsak adapter kurulmadan önce dataların hazırlanması mümkün olmayacak. Bu nedenle onCreate'teki while loop ve diğer declaration işlemlerinin tümü onStart life cycle'a da ekledik. Yalnız burada da personDataList.add() methodu call olduğundan database record'ları listView'de double olarak çıkıyor. Bu double olma durumunu engellemek için iki while loop arasına ama while loop'ların dışına personDataList.clear(); ifadesini ekleyip Arraylist'in tamamen boşaltılmasını sağladım. Eğer while loop içine koyarsak her bir iteration için ayrı ayrı clear() methodu kullanıldığından listView'da sadece tek bir record kalıyordu. Test edildi. Sistem çalışıyor. Uygulamayı yeniden başlatmaya gerek kalmadan backstack'e gönerip tekrar geri getirdiğimde yeniden işlemler double olmadan gerçekleşiyor.
- Seekbar'ın çizgilerinin uygulama tekrar başlamadan (Yani activityCreated'da View'ler yeniden oluşturulmadan) yapılan aramalar sıraında uygulamanın onStop ve onStart oluşundda güncellenmesiydi amaç. Burda onStart lfecycle'ın en altına while loop'ların altına mCustomAdapter.notifyDataSetChanged(); ifadesi eklenerek listView'deki View'lerin şeklinin güncellenmesi sağlandı. Test edildiğinde çalıştı.
-ListView'deki recordların sırasını Social Points'e göre yapmaya çalıştığımıda çok garip bir sorunla karşılaştık. İlk while loop Phone database olduğundan ikinci while loop'taki database de social pointsler olduğundan sıralamanın yapılması mümkün olmuyordu. Bu nedenle while loop'ların yerlerini değiştirdik. Yani ilk while loop own dataabse bunun içindeki ikinci while loop phone dataabse yapıldı. Bu nedenle "isFirstStart" Sharedpreference'in if condition yapıldığı kısım ilk başa alındığı. Yani bu if condition ve devamındaki else condition herşeyi belirliyor. While loop'ların yerleri değiştirildikten sonra ownDatasbe'in query() method'unnun 7. sırasında ORDERE BY, 8. sırasında LIMIT olacak şekilde düzenlemeye yappılabilir. Buralarda mutlaka String ekklenmesi gerekiyor. Mantık hatası yapıyor muşum. Yukardan aşağıya sırlamak DESC demek. Ben hep ASC üzerinde durdum. Bu artan sıralama yani aşağıdan yukarı. query() methodu'unun 7. parametresei olarak ORDER By yapılmak istenen sütun + " DESC" yaılarak yukarıdan aşağıya sırlama yapıldı. LIMIt için ise query() method'unun 8. parametresi olarak ise "10" yazılarak 2 record ile sınırlama yapıldı. Burada "10" yazılmasının sebebi buraya STRING yazılması gerekmesidir.

17.09.2017
-Seekbar'ın progressbar'ının kalılığını değiştirmek için sadece xml styles kullanıldı. Drawables klasöründe yeni bir "seekbar_progress_drawable" xml oluşturuldu. Burada layerlist tag'ları arasında hem "background" hem de "progress" id'leri için iki ayrı item oluşturuldu ve bunların shape'leri "rectangle" olarak belirlenip progress'in rengi seçildi. Bu id'lerin isimleri "background" ve "progress" olmak zorunda farklı bir id olmuyor. Daha sonra row layout'un içinde seekbar xml kodlarına android:progressDrawable="@drawable/seekbar_progress_drawable" eklendi. Burada en önemli nokta porgress bar2ın kalınlığını belirleyebilmek için android:minHeight="5dp" ve android:maxHeight="5dp" kodları aynı anda kullanıldı. Yoksa çok kalın oluyor.
-Seekbar'ın renginin runtiöe'daki social points'lere göre değişmesi gerçekleşti. Bunun için value folder'ında color.xml içine kırmızı, sarı ve yeşil renkler eklendi. CustomAdapter1 dosyası içinde if else statementler ile (personData.getSocialPoint() <= 30) gibi şartlar konarak seekBar.setProgressDrawable methodu ile ilgili renklerin puana göre değişmesi sağandı. Önemli nokta: İlk önce seekbar.getProgress() methodu ile if condition'lar belirlendi ama burda tüm seekbar progress bar'ların renkleri aynı anda değişiyordu. Herbir ecord'un renginin ayrı değişmesi için personData.getSocialPoint() ifadesi kullanıldı. Tahmin: Persondata dosyasında herbir record için bu veriler olduğundan ayrı ayrı değerler alınabiliyor. Ama seekbar.getProgress() kullanılınca data model'de bunun için bir field olmadığından sadece tek bir değerde kalıyor bu nedenle renkler aynı kalıyor. Ayrıca burda kullanılan getDrawable methodu minimum API 21 istediği için bu kısma bir if (Build.VERSION.SDK_INT >= ifadesi ile version control eklenebilir. Depreciated olan ifade API minimum 16 olan build'ler için kullanılabilir.
- Yapılacaklar: Image'ler için de aynı bu teknik kullanılabilir mi? CustomAdapter1'de social pointslere bağlı olarak farklı image'ler?? Ya da doğrudan Database'den ilgili kişinin resmi mi çekilsin?

23.09.2017
- Telefon'un rehberinde kontakların thumbnail'lerinin alınarak listeye eklenmesi üzerinde çalışldı. Bu nedenle MainFragment'ta ilk olarak query() ile thumbnail'lerin çekilebilmesi için projeksiyona ContactsContract.Contacts.PHOTO_THUMBNAIL_URI eklendi ve query ile THUMBNAIL_URI'ler alındı. Thumbnail URI'ler String olduğu için PersonData model'de değişikliğe gidilere mPic field'ının type'ı int'ten Strong olrk değiştirildi. İlgili getters&setters'larda da aynı işlem yapıldı. Sonra MainFragment'ta tüm ilgili while loop'larda mCursor'un içinde ContactsContract.Contacts.PHOTO_THUMBNAIL_URI'i alınarak mThumbNailUri olarak kaydedildi. Bu mThumbNailUri personDataList.add ile data model'e eklendi. Data Model'in kullanıldığı CustomAdapter1'de if(personData.getPic() != null){imageView.setImageURI(Uri.parse(personData.getPic()));} ifadesi ile Thumbnail_Uri'ler resme dönüştürüldü. Emülatör'de test edildi. Emülatör 'de gallery'e resim eklemek için gallery açılıyor, ilgili resim masaüstünden gallery'e sürüklenip bırakılıyor. Sonra Settings > Storage'a giriliyor. Burada SD Card önce sağdaki düğme ile eject yapılıp sonra tekrar mount yapılıyor. Bu sayede telefon yeni eklenen resmi gallery'de görüyor. Ancak emülatör'de Person'lara thumbnail eklenemediği için deneyi gerçek telefonu laptopa USB girişi ile bağlayıp yapmak zorunda kaldık. telefonun geliştirici ayarlarından USB debugging'i aktif hale getirdik. Telefonu USB ile laptop'a bağladık. ANdroid Studio'da yeşil oka basıldığında Samsung telefonu gördü. Çalıştırdığımızda telefonda bir onay mesajı çıktı onayladık ve uygulama bizim kendi tellefonuzda çıktı. Bunun avantajı: Kendi telefonunda olmasına rağmen tüm hata mesajlarını yine logcat'te görebiliyorsun. Uygulama test edildi çalışıyor. Ancak thumbnail'ler biraz küçük çıktı. Bunu düzeltmek için Row_layout'ta resmin olduğu LineraLayout'un layout_width: wrap content, layout_height: match_parent olarak değiştirdik. Image'in özelliklerini ise layout_width: 46p, layout_width: 46p ve ilgili layout_margin'leri ekledik ve test ettiğimizde görsel oalrak da daha iyi oldu. Şöyle bir sorun var: Uygulama telefonda ilk açıldığında 10-12 saniye sonraki her açılışta 4-5 saniye beliyor bunun çok yoğun Cursor projeksiyondan olduğunu veya thumbnailler'dan olduğunu veya multithread kullanmadığımdan oldupunu veya listadapter için ViewHoler kullanmadığımdan olduğunu sanıyorum. Üzerinde çalışmak lazım.

- Yukarıda yaptıklarımın tümünü geri alıp 2. Branch olarak Thumbnail kullanmadan sadece Social Points puanına göre generic bir image atama işlemini denedim. Bu işlem yukarıdakina göre çok basit. Zaten CustomAdapter1'de Socialpoints ayrımına göre seekbar renginin değişimi ile ilgili bir if else then condition mevcuttu. Sadece bu conditionlar içine imageView.setImageResource(R.mipmap.ic_launcher); eklyerek istenilen elde edild. Burada R.mipmap.ic_launcher ifadesi değiştiilerek image değiştirliebilir. bu durumda tabi PersonDataList.add() fonksitonu içined Pic parameter'ı dummy olarak rast gele bir rakam (2) yazıldı int yazılması gerektiği için. Yani bu ifadenin bir özelliği kalmadı. Ya bu sistem üzerinden devam edeceksin ya da yukarıdaki thumbnail sistemi üzerinden. Gerçek telefonda test edildiğinde performansta önemli bir değişiklik olmadı. Bu nedenle uygulamanın yavaş olmasının asıl sebebinin Thumbnail Uri query olmadığını söyleyebiliriz.

24.09.2017
- Karar: Thumbnail Uri'lerin phone contact database'den alınması, eğer thumbnail yok ise generic image'lerin social points'lere göre koyulması şeklinde bir kombinasyon kararı alındı. MainFragment içindeki database query'lerin (mCursor, Cursortest ve CallLogCursor) hepsi için kullanılmayan sütunlar silinerek ayrı ayrı projection'lar ayarlandı ve sadece lazım olan data'ların alınması sağlandı. Sistem düzeltmeler yapıldıktan sonra test edildiğinde ilginç bir şey oldu. Çifte kayıtların silindiği görüldü. Performas olarak çok büyük bir katkı sağlamadı. Belki 1-2 saniye. Demekki performas konusunda asıl sıkıntı thread'lerden kaynaklanıyor. 
- Listede yer alan ilk 10 contact bilgisi için daha önce CustomCursor'un query() method'u içine en sonda LIMIT bölümüne 10 yazılmıştı. Ancak bu durumda sadece bu ilk 10'daki data üzerinden loop'lar döndürülüyor geriye kalan kontaklar devreye sokulmuyordu. Yani bu 10'un dışında kalan bir numara arandığında bu numara listeye girmiyordu. Bu nedenle query()'lerdeki bu LIMIT kısmı silindi. CustomAdapter1'e getCount() method'u eklendi ve return olarak 10 (istenen limit sayısı) yazıldıl. Test edildiğinde liste sadece ilk 10'u gösteriyor ve ilk 10 dışında kalan numara arndığında o numara listeye giriyor. Ama çok büyük bir problem: Uygulamanın yüklemesi kontak sayısı özellikle yüsekse 1 dakikayı buluyor. Bu nedenle multiThreads veya ListView ViewHolder konusu mutlaka yapılması gerekli bir konu. Eğer başka bir çözüm yoksa.

30.09.2017
- Eğer herhangi bir arama kaydı yoksa boşuna while loop'ları çalıştırmamak için ilgili looplar if (CallLogCursor != null && CallLogCursor.getCount()>0) block'unun içine aldındı. Test edildi ve çalışıyor. Bir diğer alternatifin de if (cursor.moveToFirst()) olduğu belitilmiş.
- Android Studio yüklerken kapatılınca tekrar açıldığında bütün method'lar hata veriyordu. Her tafar kırmızı. Bunu düzeltmek için File > Invalidate Cache and Restart seçildi. Düzeldi.
- Uygulamada arka plan rengini değiştirmek için main_activity, main_fragment ve row_layout xml dosyalarında base LinearLayout widget'in arka plan renklerini değiştirildi. ActionBar'ın arka planı ve Action Bar2ın text color değişikliği için ise style.xml içinde değişiklikler yapılarak, iki yeni style eklenerek ve ilgili item'lar eklenip buralarda ilgili değişiklikler yapılarak arka plan ve textColor değiştirilebiliyor.
-Telefonla birir arandığında o kişiye 30 puan ekleniyor ama rakam üst sınır olmadığı için 100'ün üzerine çıkabiliyor (Örnek: 450 v.b). Küçük bir if condition ile eğer rakam 100'ün üzerine çıkarsa testString'i 100'e eşitleyerek sorunun çözülebileceği öngörüldü. Şimdilik comment out yapıldı ama ilerde bu kod kullanılmalı.

01.10.2017
- Gün geçtikçe Social Point'in tüm kontaklar için düşmesini öngören çalılma için dün uğraşıldığında uygulamanın  ilk açılışta bayağı yavaşladığı görüldü (20 sn falan bekliyordu listenin çıkması). Yapılanlar geri alındığında bile bu süre 10 saniyeye falan düştü anca, normalde 1 sanyede liste çıkıyordu. Bu nedenle yapılanların tamamen silinmesi için Version Control olarak 25. Version'a geri döndürüldü (kodlar copy/paste yapılarak). Ancak bu sefer de uygulama ilk açılışta hata vermeye başladı. Bu nedenle eğer Version Control amacıyla bir Version'u yeniden yüklüyorsan mutlaka uygulamanın Uninstall yapılıp tüm bilgilerin cihazdan silinmesi önemli. Yoksa Version'lar arasında uyumsuzluk oluyor ve uygulama hata verebiliyor. Uygulama silinip tekrar yüklendiğinde eski Version çalıştı ve listenin yükleme süresi tekrar 1-2 saniyeye indi. Geçici olarak dün style'lara yapılan background ve text color işlemleri de 25. Version'unkine döndürüldü.
- Subtracting social Points işlemi biraz uğraştırdı ama ens onunda çözüldü. İzlene yöntem: İlk başta OnCreate Scycle'ın hemen altına Subtract işlemi için gerekli olan gün sayısı hesaplamaları yapıldı. Burada CurrentMillis Long olarak System'den çekildi. Sonra en son işlem yapılan dayDividertime'den çıakrılıp 86400000'e bölündü, yani 60*60*1000*24. bu şekilde en son kaç gün işlem yapıldığı bulundu. Sonra bu önce String'e çevirip sonra bu String'i Interger.valueof() method'u ile int'e çevirdik ve işlemlerimizde kullandık. Acaba casting ile String'e çevirmeden doğrudan Long'u int'e çevirebilir miydik? 10 basamktan büyük sayılarda bu mümkün deil ama sonuç küçük olduğu için acaba mümkün olabilir mi? Son işlem tarihi dayDividertime için ise SharedPref'te ayrı bir alanda kayıt işlemi yapıyoruz. Bu variable lastDate variable'ından farklı. Biri uygulamanın en son açıldığı zamanı kontrol ederken diğeri en son subtract işleminin yapıldığı zamanı kayıt ediyor. Subtract günü hesaplandıktan sonra 2. loop'un else'in de (yani cursorTest'in while yapıldığı loop'ta)  if (subtractPoint > 1) condition'ı ile başlayan bir alanda (yani son işlem tarihinden 1 gün geçmiş ise) çıkarma işlemi için gerekli kodlar yazıldı. TestString'den puan çıkarılıp, bu sonuç own Database'e işlendi. Burada farklı bir value (timeValue) kullanıldı, diğer value ile clash olmaması için. Ayrıca dikkat edilmesi gereken bir nokta ilk başta replace() method'u ile Database'e yazıyorduk. Bu durumda her işlemde ilave olarak kayıt eklendiği farkedildi. Yani kayıdın üzerine değil ilave olarak yeni kayıt açıp kaydediyordu. Sonra replace()'i update() ile değiştirince sistem istenildiği gibi çalıştı. replace() vs update() method'larının kullanımına dikkat et. Dünkü uygulamanın geç açılma problemi de bu replace method'undan kaynaklanıyor olabilir. Bir kaç defadan uygulama açıldığında sürekli yeni kayıt ekliyor ve while loop'un süreleri uzuyor. Son olarak onStart() cycle'a bu işlem yapılmadı. Çünkü uygulamanın tekrar başlatıldığında geçen günün kontrol edilmesinin yeterli olacağı var sayımı yapıldı.

08.10.2017
- Thumbnail yoksa social points'e göre if condition ile generic image yapılmasını kontrol ettik. Zaten thumbnail yoksa bir generic image geliyor. Bu generic image'i social points'e göre imageView.setImageResource(R.mipmap.test_image) kodunu kullanarak değiştirebiliriz. Ancak şu aşamada buna gerek görülmedi.
- Tam emin olmamakla birlikte, subtract işleminde cursorTest Cursor'ı kullanıldığında Cursor en son item'da kalıyor olabilir ihtimalinden yola çıkarak CallLogCursor ile cursorTest'in eşleştiği while looplarına cursorTest.moveToPosition(-1); ifadesi eklendi.
- ViewHolder pattern'i şimdilik denemekten vazgeçtim. Çünkü ViewHolder Pattern çok fazle item olan bir listView'da scrolling yapıldığında computaation'ı azaltmak için kullanılıyor. Bu uygulamada listeyi zaten 10 ile limitlediğimz için bir scrolling söz konusu değil. Ama eğer bu limit kaldırılacak olursa mutlaka ve mutlaka ViewHolder design pattern kullanılmalı!
- MainFragmet'ta Cursor'lar işlerinin bittiği kod bloğunun hemen altında, databse'ler ise onDestroy method'un içinde close() yapıldı. Ama daha sonra onStart() temizlendiğinde uygulama başlayınca attemtp to re-open closed cursor hatası veriyor. Bu nedenle CallLogCursor hariç diğer tüm cursor'ları onDestroy'da close() yaptık.
- MainFragment'ta onCreate()'teki tüm herşeyi onStart()'ta da tekrar edyorduk. Ama bu yanlış br teknik. Çünkü double computation oluyor herşey. Bu sebeple object declaraton'ı en başta yapınca bu objectleri hem onCreate te hem de on Startta kullanabiliyorsun. Sadece CallLogcursor için olan query'i bıraktık. mCursor ve cursorTestquery'lerini onStart'tan silip tüm object'lerini onCreate()'te instatntiate edilen object'ler olarak tekrar kullandık. Test edildi. Önce cursor'ları close() yaptığımız için attemtp to re-open closed cursor hatası aldık. Sonra CallLogCursor hariç diğer cursor'ları onCreate() ve onSatrt()'ta kapatmayıp, onDestroy()'da kapattık. Test ettik, çalışıyor.
- Query'lerde get indexleri loop dışına çıkarman performansı artıracaktır! Denedim. Ancak çok da performansı aetırmadı. yine de bu şekilde yapılması en uygunu. Ayrıca get index methodları final type yapmak denenebilir. Benzer şekilde projection'ları final static yapmak denenebilir.
- onStart() methodu komple silip denedim. İlk açılışta 2 saniyede açılıyor İkinci açılışta 60 saniyede açılıyor. Yani asıl sıkıntı else statement'taki nested while loop içinde. Sorun: 1)UI Thread, 2)SQLLite Database update() method, 3)RegEx in while loop arasından biri olduunu tahmin ediyorum. Mutlaka contactlar için Background Thread dene

14.11.2017
- query'leri Loader ile ayrı bir Thread üzerinden yükleme seçeneğini denedik. Bunun için MainFragment'ta Loader implement yapıldı. Sonra getLoaderManager().initLoader(0, null, this) ile initialize yapıldı. Ardından life cycle'ların dışında 3 method Override yapıldı (onCreateLoader, onLoadFinished, onLoaderReset). onCreateLoader() methodu'unu içinde çekçek istediğimiz Cursor'ın özelliklerini girdik. Bunlardan onnLoadfinished bittikten sonra bize Cursor'ımızı veriyor. İşte bu Cursor'ı mCursor ile assign yaptım. Sonra yine onLoadFinished içinde query while loopları ve arrayadapter'ı ekledim. TEst edildiğinde işlem gerçekleşiyor. Ancak listenin yüklenme süresinde herhangi bir değişim olmadı. 
- Uygulama çalışırken AndroidMonitor'un içinde TraceMethods düğmesine basıldı. 2-3 saniye sonra durduruldu. İnceleme yapıldığında bu süre içinde invoke yapılan method'ları gösteriyor. Bu methodlar içinde CPU inclusive Time'ı en çok olan RegEx methodları. abi bu tablonun daha detaylı incelenmesi gerekiyor. Ancak ilk bakışta sanki yaşanan bu gecikmenin asıl sebebinin RegEx method'larından kaynaklanmış olabileceğini düşünüyorum. Bu nedenle iki yöntem öneriyorum: 1-Diğer query'leri de Loader ile yapıp süreyi ölçmek. 2-StackOverFlow'da önerildiği gibi Social Pointsleri standard Contact database içinde custom olarak kaydedip RegEx kullanımını sonlandırmak 

16.11.2017
- Gecikme sorunun RegEx'ten oldupu anlaşıldı. RegEx silinince aynı liste 2,5 saniyede çıkıyorken, loop içinde RegEx kullanılınca liste 55 sanyede yüklüyor. Yani Android Monitor'de Trace Method özellğini kullandığımızda RegEx ReplaceAll() method'unu inclusive CPU Time %77 göstermesinden (çok yüksek us - yani yatay sütun ne kadar uzunsa o kadar çok CPU time) bu method2un oldukça yoğun CPU time yediği anlaşılmış oldu. Yapılabilecekler: 1-RegEx yerine farklı bir sistem kullanılabilir mi? 2-RegEx CallLog loop içine taşınabilir mi? 3-Diğe rquery'ler Loader içine taşınsa fark oluşur mu? 4-En son çözüm: Contact database'de Custom row ile social pointslerin kaydedilmesi ve CallLog bağlantısının ContactUri'ler ile yapılması

21.10.2017
- Hız problemini çözmek için kullanılan yönetem: RegEx method'u array adapter'ı oluşturan while loop'lardan silinip CallLog'un içine koyuldu. Tabi own Database'in içine kaydedilen phone number, bu durumda phone contacts query'nin içinden alınan phone number olarak atanıyor. Tabi bu durumda CallLog loop'u ancak bir sonraki uygulama açılışında arrayadapter'ı güncelleyebiliyor. (Yani telefonn eettin uygulamayı açtın puan yansımıyor. Uygulamayı kapatıp tekrar açınca puan yansıyor) Test edildiğinde hız problemi çözüldü. Ancak phone contacts'ın içinden NORMALIZED_NUMBER diye birşey var. Bu sütun query yapıldığında null veriyor. eğer bu sütun alınabilirse RegEx kullanmaya hiç gerek kalmayacak. Nasıl kullanılabilir? Ayrıca sorun çözüldü ama bu sefer kişiler listede double entry olarak çıkıyor (Örnek: +45 65 67 68 ve +45656768 gibi iki numara ile). Bu double entry nasıl engellenebilir? Yukarda bu sorunu daha önce çözmüştük bir kontrol et. Eğer bu sorunçözülürse uygulama ok'dir denebilir. Ancak hala en uygun çözümün ya NORMALIZED_NUMBER kulanımı ya da Phone Contacts'a Custom sütun açılarak social pointslerin burada depolanması olduğunu düşünüyorum.

22.10.2017
- CursorLoader ve Content Provider/Resolver'lar içinde DISTINCT SQL komutu kullanılamıyor. Bu nedenle kontakların double entry olarak çıkması için custom bir ArrayList oluşturup foreach loop'u kullanılarak her bir loop'ta contactName2in bu ArrayList'e eklenmesi ve bu listede contactName yer alıyorsa personDataList'e ilgili contact'ın eklenmemesi şeklinde custom bir çözüm bulundu. Denendi işe yerıyor!!!!
- CallLog while loop içine if condition koyularak socailPoints 100'ün üzerine çıktığında 100'eşitledik. (testString)
- Button çıkarıldı. Toast'lar silindi. v.b. diğer ayrıntılar yapıldı.

25.10.2017
- Uygulama 3 gün boyunca kullanıldı ancak her geçen gün Social Points'lerin inmedi. Araştırınca sebebinin DayDividerTime SharedPref'inin her uygulama açılınca son tarihinin yenilenmesi. Bu sebeple her uygulama çalıştırıldığında 1 gün süresi yeniden başlıyor. Bu sorunun çözümü olarak DayDividerTime SharedPerf'in put yapıldığı methodu if (daysince > 1) condition'ı içine aldık while loop'unun dışında. Test edildi, çalışıyor.
- SubtractPoint ile DaySince variable'larının yerlerinin yanlış olduğunu farettik if condition da. Yerleri değiştirilerek sorun çözüldü. ( if(daySince > 1) yapıldı )
- Her geçen gün social points çıkarılıyor ama zaten social points 0 ise negatif olmaya başlıyor. Bunu için çıkarma işleminin içine if testString < 0 {testString = 0;} ifadesi eklenerek social points'in 0'a düşmesi engellendi.

GELİŞTİRMEYE YÖNELİK TAVSİYELER:
- History Fragment'ı projenin başında plandaydı ama sonradan çıkarıldı. Böyle bir fragment eklenerek MainFragment'ta her contact üzerine tıklandığında bu History fragment'ın açılmas ve o kontak ile ilgili kaç kere aranmış, en son aranmış v.s. gibi bilgileri görüntülenebilir.
- Whatsapp, Facebook gibi API'lar kullanıalrak bunlarda bu sisteme dahil edilebilir mi?? SMS sistemi dahil edilebilir mi?
- Tüm query'ler LoaderManager'a taşınabilir.
- Subtract işleminde arrayadapter hemen güncelleniyor ama Arama sonrası arrayAdapter bir sonraki açışta güncelleniyor. Bunu düzeltmek için ne yapılabilir? ArrayAdapter.notifyDataSetChanged()?
- Yeni bir numara eklenmesi durumunda listede çıkmıyor. Bu durum nasıl çözülebilir?
- Animasyonlar eklenebilir

Yapılacaklar:
Thread
3- Detayları şekillendir (Düğme silinmesi v.b. varsa diğer)

+ Facebook API (Rapid API)
+ Yeni numara eklenme durumunda listede çıkması
+ Toplamda kimi kaç kere aradın, kaç saat konuştun v.b. bilgileri içeren History ID fragment'ı (SQLLite kullanılabilir)
